name: Deploy to DreamHost

on:
  push:
    branches:
      - main

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18.19.0"

      - name: Verify Node Version
        run: node -v

      - name: Install dependencies
        run: npm install

      - name: Build Astro Site
        run: npm run build
        
      - name: Create Server Files
        run: |
          # Create start.js
          cat > dist/start.js << 'EOL'
          #!/usr/bin/env node
          
          /**
           * This script starts the Astro SSR server
           */
          
          import { startServer } from './server/entry.mjs';
          
          // Set default port and host
          // Using 0.0.0.0 to listen on all available network interfaces
          // This is important for hosting environments like DreamHost
          const PORT = process.env.PORT || 4321;
          const HOST = process.env.HOST || '0.0.0.0';
          
          // Start the server
          startServer({
            port: PORT,
            host: HOST
          })
            .then(({ server }) => {
              console.log(`Server running at http://${HOST}:${PORT}`);
            })
            .catch((err) => {
              console.error('Failed to start server:', err);
              process.exit(1);
            });
          EOL
          
          # Create .htaccess
          cat > dist/.htaccess << 'EOL'
          # Enable the RewriteEngine
          RewriteEngine On
          
          # Enable detailed error reporting
          Options +FollowSymLinks
          RewriteOptions Inherit
          
          # Enable proxy modules
          <IfModule mod_proxy.c>
              <IfModule mod_proxy_http.c>
                  # If the request is for an existing file or directory, serve it directly
                  RewriteCond %{REQUEST_FILENAME} -f [OR]
                  RewriteCond %{REQUEST_FILENAME} -d
                  RewriteRule ^ - [L]
          
                  # For static assets in the client directory, serve them directly
                  RewriteRule ^client/(.*)$ client/$1 [L]
          
                  # For all other requests, proxy to the Node.js server
                  # Using localhost instead of 127.0.0.1 for better compatibility
                  RewriteRule ^(.*)$ http://localhost:4321/$1 [P,L]
          
                  # Set some headers for proxied content
                  <IfModule mod_headers.c>
                      Header set X-Powered-By "Astro"
                  </IfModule>
          
                  # Set proxy timeout
                  ProxyTimeout 600
                  
                  # Enable proxy error override
                  ProxyErrorOverride On
              </IfModule>
          </IfModule>
          
          # Fallback for when proxy modules are not available
          <IfModule !mod_proxy.c>
              ErrorDocument 503 "The server is temporarily unavailable. Please contact the server administrator for assistance."
          </IfModule>
          
          # Custom error pages
          ErrorDocument 500 "Internal Server Error: The server encountered an unexpected condition that prevented it from fulfilling the request. Please contact the server administrator."
          ErrorDocument 502 "Bad Gateway: The server received an invalid response from the upstream server. Please contact the server administrator."
          ErrorDocument 503 "Service Unavailable: The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. Please contact the server administrator."
          ErrorDocument 504 "Gateway Timeout: The server was acting as a gateway or proxy and did not receive a timely response from the upstream server. Please contact the server administrator."
          EOL
          
          # Create start.sh
          cat > dist/start.sh << 'EOL'
          #!/bin/bash
          
          # Change to the directory containing this script
          cd "$(dirname "$0")"
          
          # Set environment variables
          export PORT=4321
          export HOST=0.0.0.0
          
          # Start the server
          node start.js
          EOL
          
          # Create package.json
          cat > dist/package.json << 'EOL'
          {
            "name": "jeffscotti-site-server",
            "type": "module",
            "version": "1.0.0",
            "private": true,
            "scripts": {
              "start": "node start.js",
              "test": "node test.js"
            },
            "engines": {
              "node": ">=18.19.0"
            }
          }
          EOL
          
          # Create test.js
          cat > dist/test.js << 'EOL'
          #!/usr/bin/env node
          
          /**
           * This script tests if the server is running correctly
           */
          
          import http from 'http';
          
          const PORT = process.env.PORT || 4321;
          const HOST = process.env.HOST || '0.0.0.0';
          
          // For testing, we'll use localhost since we're connecting to the local server
          const TEST_HOST = 'localhost';
          
          console.log(`Testing server at http://${TEST_HOST}:${PORT}...`);
          
          const req = http.request({
            host: TEST_HOST,
            port: PORT,
            path: '/',
            method: 'GET',
            timeout: 5000
          }, (res) => {
            console.log(`Server responded with status code: ${res.statusCode}`);
            
            let data = '';
            res.on('data', (chunk) => {
              data += chunk;
            });
            
            res.on('end', () => {
              console.log('Response received successfully');
              console.log(`Response size: ${data.length} bytes`);
              console.log('Server is running correctly!');
              process.exit(0);
            });
          });
          
          req.on('error', (err) => {
            console.error('Error connecting to server:', err.message);
            console.error('Make sure the server is running with: npm start');
            process.exit(1);
          });
          
          req.on('timeout', () => {
            console.error('Request timed out');
            req.destroy();
            process.exit(1);
          });
          
          req.end();
          EOL
          
          # Make scripts executable
          chmod +x dist/start.js dist/start.sh dist/test.js

      - name: Verify Build Output
        run: |
          echo "Verifying build output..."
          ls -la dist/
          ls -la dist/client/
          echo "Checking for critical files..."
          
          # Only check for the _astro directory which should always be present
          if [ ! -d "dist/client/_astro" ]; then
            echo "Error: dist/client/_astro directory is missing!"
            exit 1
          fi
          
          # List server directory contents for debugging
          echo "Server directory contents:"
          ls -la dist/server/
          
          echo "Build verification completed successfully."
          
      # We'll use a different approach for backups
      # The restore-site.js script can be used for manual restoration if needed

      - name: Deploy via FTP
        uses: SamKirkland/FTP-Deploy-Action@4.3.0
        with:
          server: ${{ secrets.FTP_SERVER }}
          username: ${{ secrets.FTP_USERNAME }}
          password: ${{ secrets.FTP_PASSWORD }}
          local-dir: dist/
          server-dir: ${{ secrets.FTP_REMOTE_PATH }}
          dangerous-clean-slate: false
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
          state-name: .ftp-deploy-sync-state.json
          log-level: verbose
